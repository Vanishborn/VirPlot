#!/usr/bin/env python3
# daplot.py — Genome Feature Annotation + Depth plot in SVG/PDF/PNG

import datetime
import numpy as np
from matplotlib.patches import Rectangle
import matplotlib.pyplot as plt
import os
import argparse
import csv
import yaml
import sys


#########
# funcs #
#########

def parse_gff(gff_path):
	features = []
	sequence_length = None

	with open(gff_path, "r") as fp:
		for line in fp:
			line = line.strip()

			if line.startswith("#") or not line:
				continue

			parts = line.split("\t")
			if len(parts) != 9:
				continue

			seqid, source, feature_type, start, end, score, strand, phase, attributes = parts

			if feature_type == "region" and sequence_length is None:
				sequence_length = int(end)
				continue

			if feature_type != "CDS":
				continue

			info_dict = {}
			for attr in attributes.split(";"):
				if "=" in attr:
					key, value = attr.split("=", 1)
					info_dict[key] = value

			product = info_dict.get("product", "unknown")

			features.append({
				"start": int(start),
				"end": int(end),
				"strand": strand,
				"product": product
			})

	if sequence_length is None:
		print("[DAplot] ERROR: No 'region' feature found in GFF")
		sys.exit(1)

	return sequence_length, features


def parse_depth(depth_path):
	depth = {}
	with open(depth_path, "r") as fp:
		for line in fp:
			chrom, pos, cov = line.strip().split()
			depth[int(pos)] = int(cov)
	return depth


def load_settings(yaml_path):
	with open(yaml_path, "r") as fp:
		settings = yaml.safe_load(fp)
	color_mapping = settings.get("color_mapping", {})
	default_color = settings.get("default_color", "#9F9F9F")
	depth_color   = settings.get("depth_color", "blue")
	shade_color   = settings.get("shade_color", "tomato")
	fontsize      = settings.get("annotation_fontsize", 8)
	title         = settings.get("title", "")
	return color_mapping, default_color, depth_color, shade_color, fontsize, title


def smooth_depth(y_vals, window_size=10):
	kernel = np.ones(window_size) / window_size
	return np.convolve(y_vals, kernel, mode='same')


def build_full_depth_array(depth_dict, seq_len):
	y = np.zeros(seq_len, dtype=int)
	for pos, cov in depth_dict.items():
		if 1 <= pos <= seq_len:
			y[pos - 1] = cov
	x = np.arange(1, seq_len + 1, dtype=int)
	return x, y


def call_blocks(y, T):
	"""
	y: numpy array of raw depths (len = genome length)
	T: coverage threshold
	Returns: intervals, gaps as lists of dicts with start_bp, end_bp, length_bp, min_depth, mean_depth
	"""
	covered = y >= T

	edges  = np.diff(np.r_[False, covered, False].astype(int))
	starts = np.where(edges == 1)[0]
	ends   = np.where(edges == -1)[0]

	intervals = []
	for s, e in zip(starts, ends):
		segment = y[s:e]
		intervals.append({
			"start_bp": int(s + 1),
			"end_bp": int(e),
			"length_bp": int(e - s),
			"min_depth": int(segment.min()) if segment.size else 0,
			"mean_depth": float(segment.mean()) if segment.size else 0.0
		})

	notcov = ~covered

	edges2   = np.diff(np.r_[False, notcov, False].astype(int))
	g_starts = np.where(edges2 == 1)[0]
	g_ends   = np.where(edges2 == -1)[0]

	gaps = []
	for s, e in zip(g_starts, g_ends):
		gaps.append({
			"start_bp": int(s + 1),
			"end_bp": int(e),
			"length_bp": int(e - s)
		})

	covered_bp = sum(iv["length_bp"] for iv in intervals)
	pct_covered = 100.0 * covered_bp / len(y) if len(y) else 0.0

	return intervals, gaps, pct_covered


def write_csvs(intervals, gaps, outdir, base, T):
	iv_path = os.path.join(outdir, f"{base}.intervals_ge{T}.csv")
	gp_path = os.path.join(outdir, f"{base}.gaps_lt{T}.csv")
	with open(iv_path, "w", newline="") as fp:
		w = csv.DictWriter(fp, fieldnames=["start_bp", "end_bp", "length_bp", "min_depth", "mean_depth"])
		w.writeheader()
		w.writerows(intervals)
	with open(gp_path, "w", newline="") as fp:
		w = csv.DictWriter(fp, fieldnames=["start_bp", "end_bp", "length_bp"])
		w.writeheader()
		w.writerows(gaps)
	print(f"[DAplot] Reports written: {os.path.basename(iv_path)}, {os.path.basename(gp_path)}")


############
# argparse #
############

parser = argparse.ArgumentParser(description="Virus genome feature SVG plotting tool using GFF and depth")
parser.add_argument("-g", "--gff", required=True,
	help="Path to GFF3 annotation file")
parser.add_argument("-d", "--depth", required=True,
	help="Path to samtools depth file")
parser.add_argument("-y", "--yaml", required=True,
	help="YAML file for color mapping and other specs")
parser.add_argument("-o", "--outdir", default=".",
	help="Output directory for the plot")
parser.add_argument("-n", "--normalize", action="store_true",
	help="Normalize depth values to max=1")
parser.add_argument("--grid", action="store_true",
	help="Enable background grid on depth plot")
parser.add_argument("--smooth", action="store_true",
	help="Smooth depth plot using moving average")
parser.add_argument("--name", default="daplot",
	help="Base name for output file [%(default)s]")
parser.add_argument("--no-label", action="store_true",
	help="Do not label feature names in feature rectangles")
parser.add_argument("--no-border", action="store_true",
	help="Do not draw borders around feature rectangles")
parser.add_argument("-t", "--thresholds", nargs="+", type=int, default=[1, 5],
	help="Coverage thresholds to call intervals and breaks [%(default)s]")
parser.add_argument("-r", "--report", action="store_true",
	help="Write CSV reports of intervals and breaks for each threshold")
parser.add_argument("--shade-breaks", action="store_true",
	help="Shade coverage gaps (<T) on the depth plot")
parser.add_argument("--title", action="store_true",
	help="Show title specified in YAML")
parser.add_argument("--Opdf", action="store_true",
	help="Output in PDF format")
parser.add_argument("--Opng", action="store_true",
	help="Output in PNG format")

args = parser.parse_args()


##########
# checks #
##########

if not os.path.isfile(args.gff):
	print(f"[DAplot] ERROR: GFF file not found: {args.gff}")
	sys.exit(1)
if not args.gff.endswith(".gff3"):
	print(f"[DAplot] ERROR: GFF file must end with .gff3: {args.gff}")
	sys.exit(1)
if not os.path.isfile(args.depth):
	print(f"[DAplot] ERROR: Depth file not found: {args.depth}")
	sys.exit(1)
if not os.path.isfile(args.yaml):
	print(f"[DAplot] ERROR: YAML file not found: {args.yaml}")
	sys.exit(1)
if not args.yaml.endswith(".yml") and not args.yaml.endswith(".yaml"):
	print(f"[DAplot] ERROR: YAML file extension error: {args.yaml}")
	sys.exit(1)


########
# main #
########

sequence_length, features = parse_gff(args.gff)
depth = parse_depth(args.depth)
color_mapping, default_color, depth_color, shade_color, annotation_fontsize, plot_title = load_settings(args.yaml)

print(f"[DAplot] Parsed {len(features)} features from GFF")
print(f"[DAplot] Parsed {len(depth)} depth entries")

x_full, y_full = build_full_depth_array(depth, sequence_length)

threshold_results = []
for T in args.thresholds:
	intervals, gaps, pct = call_blocks(y_full, T)
	threshold_results.append((T, intervals, gaps, pct))
	print(f"[DAplot] T={T}: {len(intervals)} intervals, {len(gaps)} breaks, {pct:.2f}% genome ≥{T}x")

if args.report:
	base = args.name
	for T, intervals, gaps, _ in threshold_results:
		write_csvs(intervals, gaps, args.outdir, base, T)


############
# plotting #
############

fig, (ax_ann, ax_depth) = plt.subplots(
	2, 1,
	figsize=(12, 4),
	sharex=True,
	gridspec_kw={"height_ratios": [1, 1]}
)
fig.subplots_adjust(hspace=0)


##############
# annotation #
##############

y_base = 0.5
feature_height = 0.6
alternate = True
label_pad = int(sequence_length * 0.02)
label_pad = int(sequence_length * 0.02)
ax_ann.plot([-label_pad, sequence_length + label_pad], [y_base, y_base], color='black', linewidth=1.2)
ax_ann.text(-label_pad * 0.4, y_base, "5'", va='center', ha='right', fontsize=10, fontweight='bold')
ax_ann.text(sequence_length + label_pad * 0.4, y_base, "3'", va='center', ha='left', fontsize=10, fontweight='bold')

for feature in features:
	start = feature["start"]
	end = feature["end"]
	product = feature["product"]
	strand = feature["strand"]
	color = color_mapping.get(product, default_color)

	is_above = alternate
	y = y_base if is_above else y_base - feature_height

	rect = Rectangle((start, y), end - start, feature_height,
					 facecolor=color,
					 edgecolor='none' if args.no_border else 'black')
	ax_ann.add_patch(rect)

	if not args.no_label:
		label_x = (start + end) / 2
		feature_length = end - start
		if feature_length < 600:
			if is_above:
				label_y = y + feature_height * 0.5
			else:
				label_y = y - feature_height * 0.5
		else:
			label_y = y + feature_height / 2

		ax_ann.text(label_x, label_y, product, ha='center', va='center', fontsize=annotation_fontsize, color='black')

	alternate = not alternate

ax_ann.set_xlim(0, sequence_length)
ax_depth.set_xlim(0, sequence_length)

ax_ann.set_ylim(-1.5, 2.0)
ax_ann.axis('off')


#########
# depth #
#########

x_depth = x_full
y_depth = y_full.astype(float)

if args.normalize:
	print(f"[DAplot] Applying normalization on depth data")
	max_val = y_depth.max() if y_depth.size else 1.0
	if max_val > 0:
		y_depth = y_depth / max_val

if args.smooth:
	print(f"[DAplot] Smoothing depth data")
	y_depth = smooth_depth(np.array(y_depth), window_size=15)

ax_depth.plot(x_depth, y_depth, color=depth_color, linewidth=0.8, alpha=0.1)
ax_depth.fill_between(x_depth, y_depth, color=depth_color, alpha=0.3)

if args.shade_breaks:
	for T, intervals, gaps, _ in threshold_results:
		y_T = T
		if args.normalize:
			denom = y_full.max() if y_full.size else 1.0
			y_T = (T / denom) if denom > 0 else 0.0
		ax_depth.axhline(y_T, color="gray", linestyle="--", linewidth=0.6)

		for g in gaps:
			ax_depth.axvspan(g["start_bp"], g["end_bp"], color=shade_color, alpha=0.20, lw=0)

ax_depth.set_ylabel("Read Depth", fontsize=10)
ax_depth.set_xlabel("Genome Position (bp)", fontsize=10)
ax_depth.set_ylim(0, max(y_depth) * 1.05 if len(y_depth) else 1)

if args.grid:
	ax_depth.grid(True, linestyle="--", linewidth=0.3)

if args.title:
	plt.tight_layout(rect=[0, 0, 1, 0.95])
	fig.suptitle(plot_title, fontsize=14, fontweight="bold")


#######
# out #
#######

os.makedirs(args.outdir, exist_ok=True)

if args.Opdf:
	ext = "pdf"
elif args.Opng:
	ext = "png"
else:
	ext = "svg"

base_filename = args.name
output_path = os.path.join(args.outdir, f"{base_filename}.{ext}")

if os.path.exists(output_path):
	timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
	alt_filename = f"{base_filename}-{timestamp}.{ext}"
	output_path = os.path.join(args.outdir, alt_filename)
	print(f"[DAplot] WARNING: File already exists. Saving to file: {alt_filename}")
else:
	print(f"[DAplot] Saving to file: {os.path.basename(output_path)}")

fig.savefig(output_path, format=ext)
print(f"[DAplot] Plot saved to: {output_path}")
