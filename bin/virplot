#!/usr/bin/env python3
# virplot — Viral Genome Feature Annotation + Depth plot

import datetime
import numpy as np
from matplotlib.patches import Rectangle
import matplotlib.pyplot as plt
import os
import argparse
import csv
import yaml
import sys


#########
# funcs #
#########

def parse_gff(gff_path):
	features = []
	sequence_length = None

	with open(gff_path, "r") as fp:
		for line in fp:
			line = line.strip()

			if line.startswith("#") or not line:
				continue

			parts = line.split("\t")
			if len(parts) != 9:
				continue

			seqid, source, feature_type, start, end, score, strand, phase, attributes = parts

			if feature_type == "region" and sequence_length is None:
				sequence_length = int(end)
				continue

			if feature_type != "CDS":
				continue

			info_dict = {}
			for attr in attributes.split(";"):
				if "=" in attr:
					key, value = attr.split("=", 1)
					info_dict[key] = value

			product = info_dict.get("product", "unknown")

			features.append({
				"start": int(start),
				"end": int(end),
				"strand": strand,
				"product": product
			})

	if sequence_length is None:
		print("[VirPlot] ERROR: No 'region' feature found in GFF")
		sys.exit(1)

	return sequence_length, features


def parse_depth(depth_path):
	depth = {}
	with open(depth_path, "r") as fp:
		for line in fp:
			chrom, pos, cov = line.strip().split()
			depth[int(pos)] = int(cov)
	return depth


def load_settings(yaml_path):
	with open(yaml_path, "r") as fp:
		settings = yaml.safe_load(fp)

	color_mapping = settings.get("color_mapping", {})
	default_color = settings.get("default_color", "#9F9F9F")
	depth_l_color = settings.get("depth_line_color", "blue")
	shade_color   = settings.get("shade_color", "tomato")
	fontsize      = settings.get("annotation_fontsize", 8)
	stacked_color = settings.get("stacked_area_colors", [])
	legend_loc    = settings.get("legend_location", "upper left")
	title         = settings.get("title", "")

	return color_mapping, default_color, depth_l_color, shade_color, fontsize, stacked_color, legend_loc, title


def smooth_depth(y_vals, window_size=10):
	kernel = np.ones(window_size) / window_size
	return np.convolve(y_vals, kernel, mode='same')


def build_full_depth_array(depth_dict, seq_len):
	y = np.zeros(seq_len, dtype=int)
	for pos, cov in depth_dict.items():
		if 1 <= pos <= seq_len:
			y[pos - 1] = cov
	x = np.arange(1, seq_len + 1, dtype=int)
	return x, y


def call_blocks(y, T):
	"""
	y: numpy array of raw depths (len = genome length)
	T: coverage threshold
	Returns: intervals, gaps as lists of dicts with start_bp, end_bp, length_bp, min_depth, mean_depth
	"""
	covered = y >= T

	edges  = np.diff(np.r_[False, covered, False].astype(int))
	starts = np.where(edges == 1)[0]
	ends   = np.where(edges == -1)[0]

	intervals = []
	for s, e in zip(starts, ends):
		segment = y[s:e]
		intervals.append({
			"start_bp": int(s + 1),
			"end_bp": int(e),
			"length_bp": int(e - s),
			"min_depth": int(segment.min()) if segment.size else 0,
			"mean_depth": float(segment.mean()) if segment.size else 0.0
		})

	notcov = ~covered

	edges2   = np.diff(np.r_[False, notcov, False].astype(int))
	g_starts = np.where(edges2 == 1)[0]
	g_ends   = np.where(edges2 == -1)[0]

	gaps = []
	for s, e in zip(g_starts, g_ends):
		gaps.append({
			"start_bp": int(s + 1),
			"end_bp": int(e),
			"length_bp": int(e - s)
		})

	covered_bp = sum(iv["length_bp"] for iv in intervals)
	pct_covered = 100.0 * covered_bp / len(y) if len(y) else 0.0

	return intervals, gaps, pct_covered


def write_csvs(intervals, gaps, outdir, base, T):
	iv_path = os.path.join(outdir, f"{base}.intervals_ge{T}.csv")
	gp_path = os.path.join(outdir, f"{base}.gaps_lt{T}.csv")
	with open(iv_path, "w", newline="") as fp:
		w = csv.DictWriter(fp, fieldnames=["start_bp", "end_bp", "length_bp", "min_depth", "mean_depth"])
		w.writeheader()
		w.writerows(intervals)
	with open(gp_path, "w", newline="") as fp:
		w = csv.DictWriter(fp, fieldnames=["start_bp", "end_bp", "length_bp"])
		w.writeheader()
		w.writerows(gaps)
	print(f"[VirPlot] Reports written: {os.path.basename(iv_path)}, {os.path.basename(gp_path)}")


############
# argparse #
############

parser = argparse.ArgumentParser(description="Virus genome feature SVG plotting tool using GFF and depth")
parser.add_argument("-g", "--gff", required=True,
	help="Path to GFF3 annotation file")
parser.add_argument("-d", "--depth", nargs="+", required=True,
	help="One or more depth filesm (stacked if multiple)")
parser.add_argument("-l", "--labels", nargs="+",
	help="Label(s) for depth line (same order as --depth)")
parser.add_argument("-y", "--yaml", required=True,
	help="YAML file for color mapping and other specs")
parser.add_argument("-o", "--outdir", default=".",
	help="Output directory for the plot")
parser.add_argument("-n", "--normalize", action="store_true",
	help="Normalize depth values to max=1")
parser.add_argument("--grid", action="store_true",
	help="Enable background grid on depth plot")
parser.add_argument("--smooth", action="store_true",
	help="Smooth depth plot using moving average")
parser.add_argument("--yscale", choices=["linear", "symlog"], default="linear",
	help="Y-axis scale method for depth plot [%(default)s]")
parser.add_argument("--linthresh", type=float, default=10.0,
	help="Symlog linear threshold around 0 [%(default)i]")
parser.add_argument("--name", default="virplot",
	help="Base name for output file [%(default)s]")
parser.add_argument("--no-label", action="store_true",
	help="Do not label feature names in feature rectangles")
parser.add_argument("--no-border", action="store_true",
	help="Do not draw borders around feature rectangles")
parser.add_argument("-t", "--thresholds", nargs="+", type=int, default=[1, 5],
	help="Coverage thresholds to call intervals and breaks [%(default)s]")
parser.add_argument("-r", "--report", action="store_true",
	help="Write CSV reports of intervals and breaks for each threshold")
parser.add_argument("--shade-breaks", action="store_true",
	help="Shade coverage gaps (<T) on the depth plot")
parser.add_argument("--legend", action="store_true",
	help="Show depth plot legend")
parser.add_argument("--title", action="store_true",
	help="Show title specified in YAML")
parser.add_argument("--Opdf", action="store_true",
	help="Output in PDF format")
parser.add_argument("--Opng", action="store_true",
	help="Output in PNG format")

args = parser.parse_args()


##########
# checks #
##########

if not os.path.isfile(args.gff):
	print(f"[VirPlot] ERROR: GFF file not found: {args.gff}")
	sys.exit(1)
if not args.gff.endswith(".gff3"):
	print(f"[VirPlot] ERROR: GFF file must end with .gff3: {args.gff}")
	sys.exit(1)
for fname in args.depth:
	if not os.path.isfile(fname):
		print(f"[VirPlot] ERROR: Depth file not found: {fname}")
		sys.exit(1)
if args.labels and len(args.labels) != len(args.depth):
	print(f"[VirPlot] ERROR: Mismatching number of labels [{len(args.labels)}] to depth files [{len(args.depth)}]")
	sys.exit(1)
if not os.path.isfile(args.yaml):
	print(f"[VirPlot] ERROR: YAML file not found: {args.yaml}")
	sys.exit(1)
if not args.yaml.endswith(".yml") and not args.yaml.endswith(".yaml"):
	print(f"[VirPlot] ERROR: YAML file extension error: {args.yaml}")
	sys.exit(1)


########
# main #
########

sequence_length, features = parse_gff(args.gff)
print(f"[VirPlot] Parsed {len(features)} features from GFF")

depth_dicts = []
for df in args.depth:
	depth_dict = parse_depth(df)
	print(f"[VirPlot] Parsed {len(depth_dict)} depth entries from {df}")
	depth_dicts.append(depth_dict)

depth_file_lengths = [len(depth_dict) for depth_dict in depth_dicts]
if len(set(depth_file_lengths)) != 1:
	print(f"[VirPlot] ERROR: Mismatching genome length in depths files {depth_file_lengths}")
	sys.exit(1)

if args.labels is None:
	labels = [os.path.splitext(os.path.basename(df))[0] for df in args.depth]
else:
	labels = args.labels

color_mapping, default_color, depth_l_color, shade_color, annotation_fontsize, stacked_color, legend_loc, plot_title = load_settings(args.yaml)
print(f"[VirPlot] Loaded settings from {args.yaml}")

x_full = np.arange(1, sequence_length + 1, dtype=int)
y_list = []

for depth_dict in depth_dicts:
	_, y = build_full_depth_array(depth_dict, sequence_length)
	y_list.append(y)

y_sum = np.sum(y_list, axis=0) if len(y_list) > 1 else y_list[0]

threshold_results = []
for T in args.thresholds:
	intervals, gaps, pct = call_blocks(y_sum.astype(int), T)
	threshold_results.append((T, intervals, gaps, pct))
	print(f"[VirPlot] T={T}: {len(intervals)} intervals, {len(gaps)} breaks, {pct:.2f}% genome ≥{T}x")

if args.report:
	base = args.name
	for T, intervals, gaps, _ in threshold_results:
		write_csvs(intervals, gaps, args.outdir, base, T)


############
# plotting #
############

fig, (ax_ann, ax_depth) = plt.subplots(
	2, 1,
	figsize=(12, 4),
	sharex=True,
	gridspec_kw={"height_ratios": [1, 1]}
)
fig.subplots_adjust(hspace=0)


##############
# annotation #
##############

y_base = 0.5
feature_height = 0.6
alternate = True
label_pad = int(sequence_length * 0.02)

ax_ann.plot([-label_pad, sequence_length + label_pad], [y_base, y_base], color='black', linewidth=1.2)
prime_5_artist = ax_ann.text(-label_pad * 0.4, y_base, "5'", va='center', ha='right', fontsize=10, fontweight='bold')
prime_3_artist = ax_ann.text(sequence_length + label_pad * 0.4, y_base, "3'", va='center', ha='left', fontsize=10, fontweight='bold')

for feature in features:
	start   = feature["start"]
	end     = feature["end"]
	product = feature["product"]
	strand  = feature["strand"]
	color   = color_mapping.get(product, default_color)

	is_above = alternate
	y = y_base if is_above else y_base - feature_height

	rect = Rectangle((start, y), end - start, feature_height,
					 facecolor=color,
					 edgecolor='none' if args.no_border else 'black')
	ax_ann.add_patch(rect)

	if not args.no_label:
		label_x = (start + end) / 2
		feature_length = end - start
		if feature_length < 500:
			label_y = y + feature_height * 1.5 if is_above else y - feature_height * 0.5
		else:
			label_y = y + feature_height / 2

		ax_ann.text(label_x, label_y, product, ha='center', va='center', fontsize=annotation_fontsize, color='black')

	alternate = not alternate

ax_ann.set_xlim(0, sequence_length)
ax_depth.set_xlim(0, sequence_length)

ax_ann.set_ylim(-1.5, 2.0)
ax_ann.axis('off')


#########
# depth #
#########

y_list_plot = list(y_list)

if args.smooth:
	print("[VirPlot] Smoothing depth data")
	y_list_plot = [smooth_depth(y, window_size=15) for y in y_list_plot]

y_plot = np.sum(y_list_plot, axis=0) if len(y_list_plot) > 1 else y_list_plot[0]

if args.normalize:
	print("[VirPlot] Normalizing depth data")
	denom = y_plot.max() or 1.0
	y_list_plot = [y / denom for y in y_list_plot]
	y_plot      = y_plot / denom

if len(y_list_plot) == 1:
	layers = ax_depth.plot(x_full, y_plot, color=depth_l_color, linewidth=0.8, alpha=0.6)
	ax_depth.fill_between(x_full, y_plot, color=depth_l_color, alpha=0.3)
else:
	k = len(y_list_plot)
	colors = stacked_color[:k] + [default_color] * max(0, k - len(stacked_color))

	layers = ax_depth.stackplot(x_full, *reversed(y_list_plot), colors=colors, alpha=0.6, step="pre")
	ax_depth.plot(x_full, y_plot, color="black", linewidth=0.3, alpha=0.8, label="Combined depth")

if args.legend:
	legend = ax_depth.legend(
		handles    = reversed(layers),
		labels     = labels,
		loc        = legend_loc,
		fontsize   = 8,
		frameon    = True,
		fancybox   = False,
		framealpha = 1.0,
		facecolor  = "white",
		edgecolor  = "black"
		)
	legend.get_frame().set_linewidth(0.5)

if args.shade_breaks:
	for _, _, gaps_T, _ in threshold_results:
		for g in gaps_T:
			ax_depth.axvspan(g["start_bp"], g["end_bp"], color=shade_color, alpha=0.15, lw=0)

ax_depth.set_ylabel("Read Depth", fontsize=10)
ax_depth.set_xlabel("Genome Position (bp)", fontsize=10)

if args.yscale == "symlog":
	ax_depth.set_yscale("symlog", linthresh=args.linthresh, linscale=1)

ax_depth.set_ylim(0, y_plot.max() * 1.05 if y_plot.size else 1)

if args.grid:
	ax_depth.grid(True, linestyle="--", linewidth=0.3)

title_artist = None
if args.title:
	title_artist = fig.text(0.5, 0.95, plot_title, ha="center", va="bottom", fontsize=14, fontweight="bold")


#######
# out #
#######

os.makedirs(args.outdir, exist_ok=True)

save_kwargs = {}
extra = []
if title_artist is not None:
	extra.append(title_artist)
extra.extend([prime_5_artist, prime_3_artist])
save_kwargs.update(dict(bbox_inches="tight", bbox_extra_artists=extra, pad_inches=0.05))

if args.Opdf:
	ext = "pdf"
elif args.Opng:
	ext = "png"
	save_kwargs.setdefault("dpi", 400)
else:
	ext = "svg"

base_filename = args.name
output_path = os.path.join(args.outdir, f"{base_filename}.{ext}")

if os.path.exists(output_path):
	timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
	alt_filename = f"{base_filename}-{timestamp}.{ext}"
	output_path = os.path.join(args.outdir, alt_filename)
	print(f"[VirPlot] WARNING: File already exists. Saving to file: {alt_filename}")
else:
	print(f"[VirPlot] Saving to file: {os.path.basename(output_path)}")

fig.savefig(output_path, format=ext, **save_kwargs)
print(f"[VirPlot] Plot saved to: {output_path}")
